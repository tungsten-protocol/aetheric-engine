//=========================================================================
// Input System
//=========================================================================
//
// Unified input handling: raw state tracking + action mapping via bindings.
//
// Architecture:
//   InputEvent → StateTracker (keys/mouse state) → ActionMapper (bindings) → Actions
//
// Each frame: clear deltas → process events → finalize → generate actions
//
//=========================================================================

//=== External Dependencies ===============================================

use std::collections::HashSet;

//=== Internal Dependencies ===============================================

use action_mapper::ActionMapper;

//=== Module Declarations =================================================

pub mod action;
pub mod event;
pub mod state_tracker;

mod action_mapper;

//=== Public API ==========================================================

pub use action::{Action, InputContext};
pub use event::{KeyCode, Modifiers, MouseButton};
pub use state_tracker::StateTracker;

//=== Internal API ========================================================

pub(crate) use event::InputEvent;

//=== InputSystem =========================================================

/// Unified input handling system coordinating state tracking and action mapping.
///
/// Provides three query levels:
///
/// 1. **Actions** (high-level): Game-defined semantic actions from bindings
/// 2. **Raw State** (mid-level): Direct key/button pressed/down/released queries
/// 3. **Mouse** (low-level): Position, delta, and button states
///
/// # Integration with Engine
///
/// When used with the engine, frame processing is handled automatically.
/// Configure bindings during initialization and query input each tick:
///
/// ```no_run
/// use aetheric_engine::EngineBuilder;
/// use aetheric_engine::core::input::{Action, KeyCode, InputContext};
///
/// #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
/// enum GameAction { Jump, Shoot }
/// impl Action for GameAction {}
///
/// EngineBuilder::<GameAction>::new()
///     .build()
///     .init(|resources| {
///         // Setup bindings during initialization
///         resources.input.bind_key(
///             KeyCode::Space,
///             GameAction::Jump,
///             InputContext::Primary
///         );
///         resources.input.bind_key(
///             KeyCode::KeyF,
///             GameAction::Shoot,
///             InputContext::Primary
///         );
///     })
///     .run(); // Engine calls process_frame() automatically each tick
/// ```
///
/// # Standalone Usage
///
/// If using InputSystem outside the engine (e.g., tests, custom loops),
/// call [`process_frame`](Self::process_frame) manually each frame:
///
/// ```
/// use aetheric_engine::core::input::{InputSystem, Action, KeyCode};
///
/// #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
/// enum GameAction { Jump }
/// impl Action for GameAction {}
///
/// let mut input = InputSystem::<GameAction>::new()
///     .with_binding(KeyCode::Space, GameAction::Jump);
///
/// // In your custom game loop:
/// // input.process_frame(&event_batches);
///
/// // Then query input:
/// if input.is_key_pressed(KeyCode::Space) {
///     // Handle jump
/// }
/// ```
pub struct InputSystem<A: Action> {
    /// Action mapping system (bindings, contexts)
    mapper: ActionMapper<A>,

    /// Actions triggered this frame (generated by process_frame)
    current_actions: Vec<A>,
}

impl<A: Action> InputSystem<A> {
    //--- Construction -----------------------------------------------------

    /// Creates a new input system with Primary context active and no bindings.
    pub(crate) fn new() -> Self {
        Self {
            mapper: ActionMapper::new(),
            current_actions: Vec::new(),
        }
    }

    //--- Frame Processing -------------------------------------------------

    /// Processes all input events for the current frame.
    ///
    /// When using the engine, this is called automatically each tick. Only call
    /// manually if using InputSystem standalone (testing, custom game loops).
    ///
    /// # Processing Pipeline
    /// 1. Clear previous frame's deltas (pressed/released flags)
    /// 2. Update state from all event batches
    /// 3. Finalize continuous inputs (mouse delta)
    /// 4. Generate actions via current bindings
    ///
    /// # Arguments
    ///
    /// * `state` - The state tracker to update and query
    /// * `event_batches` - Slices of events (typically discrete + continuous)
    pub fn process_frame(&mut self, state: &mut StateTracker, event_batches: &[Vec<InputEvent>]) {
        // 1. Clear previous frame's deltas
        state.clear();

        // 2. Process all event batches
        for batch in event_batches {
            state.process_events(batch);
        }

        // 3. Calculate mouse delta AFTER all batches processed
        state.finalize_frame();

        // 4. Generate actions with deduplication
        self.current_actions.clear();
        let modifiers = state.modifiers();
        let mut seen = HashSet::new();

        for key in state.keys_pressed() {
            if let Some(action) = self.mapper.map_key(*key, modifiers) {
                if seen.insert(action) {
                    self.current_actions.push(action);
                }
            }
        }

        for btn in state.buttons_pressed() {
            if let Some(action) = self.mapper.map_button(*btn, modifiers) {
                if seen.insert(action) {
                    self.current_actions.push(action);
                }
            }
        }
    }

    //=====================================================================
    // Action Queries
    //=====================================================================

    /// Returns actions triggered this frame.
    ///
    /// Empty if no bindings matched or no inputs received.
    #[must_use]
    #[inline]
    pub fn actions(&self) -> &[A] {
        &self.current_actions
    }

    /// Checks if a specific action was triggered this frame.
    ///
    /// Equivalent to `input.actions().contains(action)` but more semantic.
    #[inline]
    pub fn has_action(&self, action: &A) -> bool {
        self.current_actions.contains(action)
    }

    //=====================================================================
    // Fluent Configuration API (Immutable Chain)
    //=====================================================================

    /// Binds a key to an action using fluent API (consumes self).
    ///
    /// Binding uses the current active context. For runtime modification
    /// use [`bind_key`](Self::bind_key) instead.
    ///
    /// # Examples
    /// ```
    /// # use aetheric_engine::core::input::{InputSystem, Action, KeyCode};
    /// # #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    /// # enum GameAction { Jump }
    /// # impl Action for GameAction {}
    /// let input = InputSystem::<GameAction>::new()
    ///     .with_binding(KeyCode::Space, GameAction::Jump);
    /// ```
    pub fn with_binding(mut self, key: KeyCode, action: A) -> Self {
        let ctx = self.mapper.current_context();
        self.mapper.bind_key(key, action, ctx);
        self
    }

    /// Binds a key with modifiers (exact match required).
    ///
    /// # Examples
    /// ```
    /// # use aetheric_engine::core::input::{InputSystem, Action, KeyCode, Modifiers};
    /// # #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    /// # enum GameAction { Save }
    /// # impl Action for GameAction {}
    /// let input = InputSystem::<GameAction>::new()
    ///     .with_binding_mods(KeyCode::KeyS, Modifiers::CTRL, GameAction::Save);
    /// ```
    pub fn with_binding_mods(
        mut self,
        key: KeyCode,
        modifiers: Modifiers,
        action: A
    ) -> Self {
        let ctx = self.mapper.current_context();
        self.mapper.bind_key_with_mods(key, modifiers, action, ctx);
        self
    }

    /// Sets the active context using fluent API.
    ///
    /// # Examples
    /// ```
    /// # use aetheric_engine::core::input::{InputSystem, Action, InputContext};
    /// # #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    /// # enum GameAction { Jump }
    /// # impl Action for GameAction {}
    /// let input = InputSystem::<GameAction>::new()
    ///     .with_context(InputContext::custom(0));
    /// ```
    pub fn with_context(mut self, context: InputContext) -> Self {
        self.mapper.set_context(context);
        self
    }

    //=====================================================================
    // Runtime Configuration API (Mutable)
    //=====================================================================

    /// Binds a key to an action at runtime in the specified context.
    ///
    /// Replaces existing binding if present. For initialization-time configuration
    /// prefer [`with_binding`](Self::with_binding).
    ///
    /// # Parameters
    ///
    /// - `context`: Which input context this binding applies to. Use
    ///   `InputContext::Primary` for main gameplay, or create custom contexts
    ///   with `InputContext::custom(id)` for menus, vehicles, etc.
    ///
    /// # Example
    ///
    /// ```
    /// # use aetheric_engine::core::input::{InputSystem, Action, InputContext, KeyCode};
    /// # #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    /// # enum GameAction { Jump }
    /// # impl Action for GameAction {}
    /// let mut input = InputSystem::<GameAction>::new();
    ///
    /// // Bind in primary gameplay context
    /// input.bind_key(KeyCode::Space, GameAction::Jump, InputContext::Primary);
    /// ```
    pub fn bind_key(&mut self, key: KeyCode, action: A, context: InputContext) {
        self.mapper.bind_key(key, action, context);
    }

    /// Binds a key with modifiers at runtime (modifiers must match exactly).
    ///
    /// Context parameter: see [`bind_key`](Self::bind_key) for context usage.
    pub fn bind_key_with_mods(
        &mut self,
        key: KeyCode,
        modifiers: Modifiers,
        action: A,
        context: InputContext,
    ) {
        self.mapper.bind_key_with_mods(key, modifiers, action, context);
    }

    /// Binds a mouse button to an action at runtime.
    ///
    /// Context parameter: see [`bind_key`](Self::bind_key) for context usage.
    pub fn bind_mouse(&mut self, button: MouseButton, action: A, context: InputContext) {
        self.mapper.bind_mouse(button, action, context);
    }

    /// Binds a mouse button with modifiers (exact match).
    ///
    /// Context parameter: see [`bind_key`](Self::bind_key) for context usage.
    pub fn bind_mouse_with_mods(
        &mut self,
        button: MouseButton,
        modifiers: Modifiers,
        action: A,
        context: InputContext,
    ) {
        self.mapper.bind_mouse_with_mods(button, modifiers, action, context);
    }

    /// Removes all bindings for a key in the specified context.
    ///
    /// Other contexts are unaffected. Context parameter: see [`bind_key`](Self::bind_key).
    pub fn unbind_key(&mut self, key: KeyCode, context: InputContext) {
        self.mapper.unbind_key(key, context);
    }

    /// Clears all bindings for a context.
    ///
    /// Use this when switching game modes to remove all previous bindings.
    /// Other contexts are unaffected.
    pub fn clear_context(&mut self, context: InputContext) {
        self.mapper.clear_context(context);
    }

    //=====================================================================
    // Context Management
    //=====================================================================

    /// Sets the active input context (only active bindings generate actions).
    pub fn set_context(&mut self, context: InputContext) {
        self.mapper.set_context(context);
    }

    /// Returns the currently active context.
    #[must_use]
    pub fn current_context(&self) -> InputContext {
        self.mapper.current_context()
    }

}

//=========================================================================
// Default Implementation
//=========================================================================

impl<A: Action> Default for InputSystem<A> {
    fn default() -> Self {
        Self::new()
    }
}

//=========================================================================
// Unit Tests
//=========================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    enum TestAction {
        Jump,
        Shoot,
        MoveUp,
        Save,
        AltFire,
    }

    impl Action for TestAction {}

    fn key_down(key: KeyCode) -> InputEvent {
        InputEvent::KeyDown {
            key,
            modifiers: Modifiers::NONE
        }
    }

    fn key_down_with_mods(key: KeyCode, mods: Modifiers) -> InputEvent {
        InputEvent::KeyDown {
            key,
            modifiers: mods
        }
    }

    fn key_up(key: KeyCode) -> InputEvent {
        InputEvent::KeyUp {
            key,
            modifiers: Modifiers::NONE
        }
    }

    fn mouse_up(button: MouseButton) -> InputEvent {
        InputEvent::MouseButtonUp {
            button,
            modifiers: Modifiers::NONE
        }
    }

    fn mouse_down(button: MouseButton) -> InputEvent {
        InputEvent::MouseButtonDown {
            button,
            modifiers: Modifiers::NONE
        }
    }

    fn mouse_move(x: f32, y: f32) -> InputEvent {
        InputEvent::MouseMoved { x, y }
    }

    //=====================================================================
    // Basic Functionality
    //=====================================================================

    #[test]
    fn new_system_starts_empty() {
        let input = InputSystem::<TestAction>::new();

        assert!(input.actions().is_empty());
        assert_eq!(input.current_context(), InputContext::Primary);
    }

    #[test]
    fn process_frame_generates_actions() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::Space, TestAction::Jump, InputContext::Primary);

        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);

        assert_eq!(input.actions(), &[TestAction::Jump]);
        assert!(input.has_action(&TestAction::Jump));
    }

    #[test]
    fn process_frame_deduplicates_actions() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::KeyW, TestAction::MoveUp, InputContext::Primary);
        input.bind_key(KeyCode::ArrowUp, TestAction::MoveUp, InputContext::Primary);

        let events = [vec![
            key_down(KeyCode::KeyW),
            key_down(KeyCode::ArrowUp),
        ]];
        input.process_frame(&mut state, &events);

        assert_eq!(input.actions(), &[TestAction::MoveUp]);
    }

    #[test]
    fn actions_clear_between_frames() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::Space, TestAction::Jump, InputContext::Primary);

        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Jump]);

        input.process_frame(&mut state, &[]);
        assert!(input.actions().is_empty());
    }

    #[test]
    fn context_switching() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        let gameplay = InputContext::Primary;
        let menu = InputContext::custom(0);

        input.bind_key(KeyCode::Space, TestAction::Jump, gameplay);
        input.bind_key(KeyCode::Space, TestAction::Shoot, menu);

        // Gameplay context
        input.set_context(gameplay);
        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Jump]);

        // Release and switch
        let events = [vec![key_up(KeyCode::Space)]];
        input.process_frame(&mut state, &events);

        // Menu context
        input.set_context(menu);
        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Shoot]);
    }

    //=====================================================================
    // Modifier Tests
    //=====================================================================

    #[test]
    fn modifiers_exact_match_required() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key_with_mods(
            KeyCode::KeyS,
            Modifiers::CTRL,
            TestAction::Save,
            InputContext::Primary
        );

        // Without Ctrl - no action
        let events = [vec![key_down(KeyCode::KeyS)]];
        input.process_frame(&mut state, &events);
        assert!(input.actions().is_empty());

        // Release S
        let events = [vec![key_up(KeyCode::KeyS)]];
        input.process_frame(&mut state, &events);

        // With Ctrl - action triggered
        let events = [vec![key_down_with_mods(KeyCode::KeyS, Modifiers::CTRL)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Save]);
    }

    #[test]
    fn modifiers_extra_keys_dont_match() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key_with_mods(
            KeyCode::KeyS,
            Modifiers::CTRL,
            TestAction::Save,
            InputContext::Primary
        );

        // Ctrl+Shift+S should NOT match Ctrl+S
        let events = [vec![key_down_with_mods(KeyCode::KeyS, Modifiers::SHIFT_CTRL)]];
        input.process_frame(&mut state, &events);
        assert!(input.actions().is_empty());
    }

    #[test]
    fn same_key_different_modifiers() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::KeyS, TestAction::Shoot, InputContext::Primary);
        input.bind_key_with_mods(
            KeyCode::KeyS,
            Modifiers::CTRL,
            TestAction::Save,
            InputContext::Primary
        );

        // S alone → Shoot
        let events = [vec![key_down(KeyCode::KeyS)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Shoot]);

        // Release S
        let events = [vec![key_up(KeyCode::KeyS)]];
        input.process_frame(&mut state, &events);

        // Ctrl+S → Save
        let events = [vec![key_down_with_mods(KeyCode::KeyS, Modifiers::CTRL)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Save]);
    }

    //=====================================================================
    // Mouse Tests
    //=====================================================================

    #[test]
    fn mouse_button_binding() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_mouse(MouseButton::Left, TestAction::Shoot, InputContext::Primary);

        let events = [vec![mouse_down(MouseButton::Left)]];
        input.process_frame(&mut state, &events);

        assert_eq!(input.actions(), &[TestAction::Shoot]);
    }

    #[test]
    fn mouse_button_with_modifiers() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_mouse_with_mods(
            MouseButton::Left,
            Modifiers::CTRL,
            TestAction::AltFire,
            InputContext::Primary
        );

        // Left click without Ctrl - no action
        let events = [vec![mouse_down(MouseButton::Left)]];
        input.process_frame(&mut state, &events);
        assert!(input.actions().is_empty());

        // Release Mouse
        let events = [vec![mouse_up(MouseButton::Left)]];
        input.process_frame(&mut state, &events);

        // Ctrl+Left click - action triggered
        let events = [vec![InputEvent::MouseButtonDown {
            button: MouseButton::Left,
            modifiers: Modifiers::CTRL
        }]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::AltFire]);
    }

    //=====================================================================
    // Binding Management Tests
    //=====================================================================

    #[test]
    fn unbind_key_removes_binding() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::Space, TestAction::Jump, InputContext::Primary);

        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Jump]);

        // Unbind
        input.unbind_key(KeyCode::Space, InputContext::Primary);

        input.process_frame(&mut state, &events);
        assert!(input.actions().is_empty());
    }

    #[test]
    fn clear_context_removes_all_bindings() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        let gameplay = InputContext::Primary;
        let menu = InputContext::custom(0);

        input.bind_key(KeyCode::Space, TestAction::Jump, gameplay);
        input.bind_key(KeyCode::KeyS, TestAction::Shoot, gameplay);
        input.bind_key(KeyCode::KeyE, TestAction::Save, menu);

        // Clear gameplay context
        input.clear_context(gameplay);

        let events = [vec![key_down(KeyCode::Space)]];
        input.set_context(gameplay);
        input.process_frame(&mut state, &events);
        assert!(input.actions().is_empty());

        // Menu binding still exists
        input.set_context(menu);
        let events = [vec![key_down(KeyCode::KeyE)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Save]);
    }

    #[test]
    fn rebinding_replaces_action() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::Space, TestAction::Jump, InputContext::Primary);

        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Jump]);

        // Release Space
        let events = [vec![key_up(KeyCode::Space)]];
        input.process_frame(&mut state, &events);

        // Rebind to different action
        input.bind_key(KeyCode::Space, TestAction::Shoot, InputContext::Primary);

        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Shoot]);
    }

    //=====================================================================
    // Fluent API Tests
    //=====================================================================

    #[test]
    fn fluent_api_chaining() {
        let input = InputSystem::<TestAction>::new()
            .with_context(InputContext::Primary)
            .with_binding(KeyCode::Space, TestAction::Jump)
            .with_binding(KeyCode::KeyF, TestAction::Shoot);

        // Can't test directly without processing, but compilation succeeds
        assert_eq!(input.current_context(), InputContext::Primary);
    }

    #[test]
    fn fluent_api_with_modifiers() {
        let mut input = InputSystem::<TestAction>::new()
            .with_binding_mods(KeyCode::KeyS, Modifiers::CTRL, TestAction::Save);
        let mut state = StateTracker::new();

        let events = [vec![key_down_with_mods(KeyCode::KeyS, Modifiers::CTRL)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Save]);
    }

    //=====================================================================
    // Edge Cases & Stress Tests
    //=====================================================================

    #[test]
    fn many_bindings_same_context() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        // Bind 50 keys to same action
        for i in 0..26 {
            let key = match i {
                0 => KeyCode::KeyA,
                1 => KeyCode::KeyB,
                2 => KeyCode::KeyC,
                3 => KeyCode::KeyD,
                4 => KeyCode::KeyE,
                5 => KeyCode::KeyF,
                6 => KeyCode::KeyG,
                7 => KeyCode::KeyH,
                8 => KeyCode::KeyI,
                9 => KeyCode::KeyJ,
                10 => KeyCode::KeyK,
                11 => KeyCode::KeyL,
                12 => KeyCode::KeyM,
                13 => KeyCode::KeyN,
                14 => KeyCode::KeyO,
                15 => KeyCode::KeyP,
                16 => KeyCode::KeyQ,
                17 => KeyCode::KeyR,
                18 => KeyCode::KeyS,
                19 => KeyCode::KeyT,
                20 => KeyCode::KeyU,
                21 => KeyCode::KeyV,
                22 => KeyCode::KeyW,
                23 => KeyCode::KeyX,
                24 => KeyCode::KeyY,
                25 => KeyCode::KeyZ,
                _ => KeyCode::Space,
            };
            input.bind_key(key, TestAction::Jump, InputContext::Primary);
        }

        // Any key triggers action
        let events = [vec![key_down(KeyCode::KeyM)]];
        input.process_frame(&mut state, &events);
        assert_eq!(input.actions(), &[TestAction::Jump]);
    }

    #[test]
    fn simultaneous_inputs_multiple_actions() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        input.bind_key(KeyCode::Space, TestAction::Jump, InputContext::Primary);
        input.bind_key(KeyCode::KeyF, TestAction::Shoot, InputContext::Primary);
        input.bind_mouse(MouseButton::Left, TestAction::AltFire, InputContext::Primary);

        let events = [vec![
            key_down(KeyCode::Space),
            key_down(KeyCode::KeyF),
            mouse_down(MouseButton::Left),
        ]];
        input.process_frame(&mut state, &events);

        assert_eq!(input.actions().len(), 3);
        assert!(input.has_action(&TestAction::Jump));
        assert!(input.has_action(&TestAction::Shoot));
        assert!(input.has_action(&TestAction::AltFire));
    }

    #[test]
    fn empty_event_batches_handled() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        // Process empty batches shouldn't panic
        input.process_frame(&mut state, &[]);
        input.process_frame(&mut state, &[vec![], vec![], vec![]]);

        assert!(input.actions().is_empty());
    }

    #[test]
    fn no_binding_no_action() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        // Press key with no binding
        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);

        assert!(input.actions().is_empty());
    }

    #[test]
    fn context_isolation() {
        let mut input = InputSystem::<TestAction>::new();
        let mut state = StateTracker::new();

        let ctx1 = InputContext::Primary;
        let ctx2 = InputContext::custom(0);

        input.bind_key(KeyCode::Space, TestAction::Jump, ctx1);

        // No binding in ctx2
        input.set_context(ctx2);
        let events = [vec![key_down(KeyCode::Space)]];
        input.process_frame(&mut state, &events);

        assert!(input.actions().is_empty());
    }
}